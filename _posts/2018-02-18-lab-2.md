---
title: "Rhythm and Chroma"
header:
  teaser: /assets/images/Lab2.png
categories:
  - Digital Signal Processing
tags:
  - rhythm
  - chroma
toc: true
---

# Introduction
In this project we look at how similar certain seconds in a music track are to each other, as well as look into the rhythm and chroma of a certain music track. We will use these features in a future project to compare two music tracks to see if they are part of the same genre of music using this analysis. 
<figure>
	<a href="/assets/images/Lab2.png"><img src="/assets/images/Lab2.png"></a>
</figure>

# Main Project

## 1. Intro

In this lab, we look at more digital signal processing for content-based music information retrieval. The two main features we are looking at are rhythm and tonality. We will be using the same tracks for lab 1 to investigate these features.  
These features are more useful for all frequencies of music as opposed to the features investigated in lab one that only helped for low frequency music. 

## 2. Rhythm 

Musical rhythm can be loosely defined as the presence of repetitive patterns in the temporal structure of music. We will implement several techniques to detect the presence of rhythmic structures in an audio track. 
Given an audio segment of duration T = 24 seconds, the goal is to compute a score that measures how often spectral patterns are repeated. Formally, we will compute a vector, B, such that B(lag) quantifies the presence of similar spectral patterns for frames that are lag frames apart. The lag associated with the largest entry in the array B is a good candidate for the period in the rhythmic structure.  
We explain below two approaches to compute the array B. 

### 2.1 Spectral Decomposition

We‚Äôll first compute the mfcc coefficients for a frame as explained in lab 1, thereby obtaining a vector, and then modify each coefficient of the mfcc vector with a nonlinearity. The purpose of the non-linearity is to account for the non-linear perception of loudness by the human auditory system: loudness does not increase linearly with sound intensity (measured, for instance, in Watts/m<sup>2</sup>). A good approximation to the perceptual response of the human auditory system within a given critical band of hearing is obtained by taking the logarithm of the energy in that band. We therefore define an mfcc vector in decibels for each frame as 

![Equation21]({{ site.url }}/assets/images/equation2-1.PNG)

where the logarithm is taken of each element. 

Later you will write a function that returns an mfcc array, mfcc(k,n), comprising the mfcc vectors corresponding to each frame of an audio track. This array will have dimensions

![Equation22]({{ site.url }}/assets/images/equation2-2.PNG)

where N<sub>f</sub> = f<sub>s</sub>T/N. Here N<sub>f</sub> is the number of frames, N = 512 is the frame size in samples, f<sub>s</sub> is the audio sampling rate, and K = N/2 + 1 is the number of frequencies. As in lab 1, we choose nbanks = 40 as the number of mels. The entire analysis described below is performed at the level of frames. 

### 2.2 Spectrum histogram

We propose to construct a visual representation of a musical track by counting how often a given note is played at a given amplitude (we consider each index of the mfcc vector to be a ‚Äúnote‚Äù, and measure amplitude in dB). 

	Assignment
	1. Modify your function that computes the mfcc to return 
	the mfcc in decibels. 
	2. Construct a two-dimensional 
	spectrum histogram (a matrix of counts), with 40 
	columns ‚Äîone for each mfcc index, and 81 rows ‚Äîone for 
	each amplitude level, measured in dB. The amplitude range 
	we care about is from -20 dB to 60 dB, so clip the mel 
	values to that range. In other words, values less than 
	-20 dB map to -20, values greater than 60 dB map to 60, 
	and values inbetween map to the nearest integer in the 
	set {‚àí20,‚àí19,‚àí18,...,60}. Once you have the counts, 
	normalize the histogram such that the sum along each 
	column (i.e. for each ‚Äúnote‚Äù) is one. 
	3. Display, using the MATLAB function imagesc, the 
	spectrum histogram for the 12 audio tracks supplied 
	for the first lab. 
	
1. Here is the MATLAB code of the function mfcc returned in decibels

```
function [ mfccp ] = mfcc( fbank,Xn,~) 
%mfcc Computes the Mel frequency coeffecients 
%   The mel-spectrum (MFCC) coefficient of the n-th frame is defined for 
%   p = 1,...,NB 
narginchk(2, 3); 
% Xn=freqDist(filename); 
mfccp=(fbank*abs(Xn)).^2; % Lets us still use non-log mfcc (if needed) 
if(nargin==3)     
	mfccp=10*log10(mfccp);     
	return; 
end 
end 

function [ soundExtract,p ] = extractSound( filename, time) 
%extractSound Extracts time (in seconds) from the middle of the song 
%   Write a MATLAB function that extract T seconds of music from a 
%   given track. You will use the MATLAB function audioread to 
%   read a track and the function play to listen to the track. 
narginchk(1, 2); 
if(nargin == 1)     
	time = 24; 
end 
info = audioinfo(filename); 
song=audioread(filename); 
if time >= info.Duration     
	soundExtract=song;     
	if(nargout == 2)         
		p=audioplayer(soundExtract,info.SampleRate);     
	end     
	return; 
elseif time<= 1/info.SampleRate     
	error('Too small of a time to sample'); 
end 
samples=time*info.SampleRate;   
soundExtract=song(floor(info.TotalSamples/2)-floor(samples/2):1: ...     
	floor(info.TotalSamples/2)+floor(samples/2)); 
if(nargout == 2)     
	p=audioplayer(soundExtract,info.SampleRate); 
end 
end
```

2, 3. In order to visualize the mfcc, a spectrum histogram is created which maps each mfcc index and the corresponding amplitude levels to a color displaying how often each mfcc index occured at the respective volume. Below is the histogram for ‚Äòtrack201-classical‚Äô which aside from the very low sounds, most of the pitches were at around the same volume.

![Figure21]({{ site.url }}/assets/images/figure2-1.PNG)

### 2.3 Similarity Matrix

The first stage involves computing a similarity matrix defined as follows 

![Equation23]({{ site.url }}/assets/images/equation2-3.PNG)

Here we are considering the mel spectral signature of each frame to be a vector, and using the dot product to compute S(i,j), the cosine of the angle between the vectors corresponding to frames i and j. For this exercise we use the non-dB version of the mfcc coefficients (i.e., we don‚Äôt first take 10 times the base 10 log of the mfcc values). We note that mfcc is always positive in this case, and therefore 0 ‚â§ S(i,j) ‚â§ 1. 

The similarity S(i,j) is large, S(i,j) ‚âà 1, if the notes being played in frame i are similar to the notes being played in frame j. We note that this similarity is independent of the loudness of the music (the cosine between two vectors does not depend on their magnitude). 

	Assignment 
	4. Implement the computation of the similarity matrix, and display 
	the similarity matrices (color-coded) for the 12 audio tracks 
	supplied for the first lab. Use colormap(‚Äôjet‚Äô) and imagesc( ). 
	
The code for the similarity matrix and figure of ‚Äòtrack201-classical‚Äô for the similarity matrix is shown below.

```
function [ sim ] = simMatrix(mfccp,filename,~) 
%simMatrix displays the similarity matrix for the mel coefficients 
%   The similarity matrix is defined as follows: 
%   S(i,j) = sum_{k=1}^{nbanks}{ 
%   (mfcc(k,i)*mfcc(k,j))/(norm(mfcc(:,i)) * norm(mfcc(:,j))) 
% fbank=melBank(); 
% mfccp=mfcc(fbank,filename); 
[a,b]=size(mfccp); % Preallocate matrix 
sim=zeros(b,b); 
normI=sqrt(sum(abs(mfccp).^2,1)); 
parfor i=1:b %frame i     
	for j=1:b %frame j         
		for k=1:a %fbank k             
			sim(i,j)=sim(i,j)+...                 
				(mfccp(k,i)*mfccp(k,j)/(normI(j).*normI(i)));          
		end     
	end 
end   
if(nargin == 3)     
	h=figure;     
	imagesc(sim);     
	xlabel('Frame Number');     
	ylabel('Frame Number');     
	title({'Similarity Matrix:'; filename});     
	colorbar;     
	colormap 'jet';     
	saveas(gca,['SimMatrix' filename(6:end-4) '.png']);     
	close(h); 
end 
end	
```

In the figure it can be seen that classical music is mostly green and blue which is an indication that the music has a lot of different notes being played. As can be heard in the music, classical music has a widespread amount of notes being played throughout, so this physically makes sense for this track. 

![Figure22]({{ site.url }}/assets/images/figure2-2.PNG)

### 2.4 A first estimate of the rhythm 

We note that the entries S(n,n + l) in the similarity matrix (3) are always at a distance (time lag) of l frames. In order to detect the presence of patterns that are repeated every l frames we compute, 

![Equation24]({{ site.url }}/assets/images/equation2-4.PNG)

B(l) is the sum of all the entries on the l<sup>th</sup> upper diagonal. Indeed, B(0) is the sum of all the entries on the main diagonal. Similarly, B(1) is the sum of the entries on the first upper diagonal, etc. We note that 

![Equation25]({{ site.url }}/assets/images/equation2-5.PNG)

The index l ‚â• 1 associated with the largest value of B(l) corresponds to the presence of a rhythmic period of l √ó N/f<sub>s</sub> seconds.

        Assignment
        5. Implement the computation of the rhythm index B(l) defined 
	in (4). Plot the vector B as a function of the lag l = 0,
	Nf ‚àí1 for the 12 tracks. Comment on the presence, or absence, 
	of a strong rhythmic pattern. 

The code for the computation of the rhythm index and plot of the rhythm index of ‚Äòtrack396‚Äô is shown below. 

```
function [ B ] = rhythmIndex( filename,sim,~) 
%rhythmIndex Identifies rhythmic periods 
%   B(l) is the sum of all the entries on the lth upper diagonal. 
%   The index l associated with the largest value of B(l) corresponds to 
%   the presence of a rhythmic period of l*K/f_s seconds
% sim = simMatrix( filename);
[len,~]= size(sim);
B=zeros(1,len);
parfor l=0:len-1
        B(l+1)=(1/(len-l))*sum(diag(sim,l));
end
if(nargin==3)
        h=figure;
        plot(B);
        xlim([0,len]);
        title({'Rhythm Index B(l):'; filename});
        xlabel('lag (frames)');
        ylabel('Presence of rhythmic period');
        saveas(gca,['RhythmIndex' filename(6:end-4) '.png']);
        close(h);
end
end
```

![Figure23]({{ site.url }}/assets/images/figure2-3.PNG)

### 2.5 Periodicity Histograms

Many entries in the similarity matrix are small, and are not useful to quantify the presence of rhythm. Furthermore, it would be interesting to be able to quantify the rhythm as a function of tempo. We can define a notion of tempo, measured in beats per minute, by taking the inverse of the rhythmic period, l ¬∑ N/f<sub>s</sub>. We get 

![Equation26]({{ site.url }}/assets/images/equation2-6.PNG)

Note the multiplication by 60 to convert beats-per-second to BPM. Re-arranging this formula we can find the l (frame lag) corresponding to a given BPM of interest as 

![Equation27]({{ site.url }}/assets/images/equation2-7.PNG)

Now we‚Äôll describe an algorithm to compute the probability of finding a large similarity at a given tempo of interest. 

	Assignment 
	6. Compute the median ùëÜ of the matrix S. 
	
6. The code to compute the median of S is below:

```
function [ AC ] = autoC( filename,sim,~ ) 
%autoC Computes the autocorrelation of a song 
%   In general, if two frames i and j are similar, we can find out 
%   if they are repeated later in the segment, at time j+l   
info = audioinfo(filename); 
% sim = simMatrix( filename); 
[len,~]=size(sim); 
AC=zeros(1,len);   
parfor l=0:len-1     
	for i=1:len         
		for j=1:len-l            
			AC(l+1)=AC(l+1)+(sim(i,j)*sim(i,j+l));
		end     
	end     
	AC(l+1)=AC(l+1)*(1/(len*(len-l))); 
end   
if(nargin==3)     
	h=figure;     
	xAxis=linspace(0,len/info.SampleRate,len);     
	plot(xAxis,AC);     
	xlim([0,len/info.SampleRate]);     
	title({'Autocorrelation AC(l):'; filename});     
	xlabel('Lag (secs)');     
	ylabel('Autocorrelation');     
	saveas(gca,['AutoC' filename(6:end-4) '.png']);     
	close(h); 
end   
end 
```

### 2.6 A better estimate of the rhythm 

Above we looked at the similarity between frames that are a fixed lag, l, apart in time by computing the vector B(l). However, it is possible to look for patterns within the similarity matrix related to l in other ways. In particular, we can ask the following question: if the spectral signature at time i is related to the signature at time j (i.e. S(i,j) is relatively large), is it also related to the spectral signature at time j + l (i.e. is S(i,j + l) also relatively large?). A lag, l, will be a candidate for a rhythmic period if there are many i and j combinations such that if S(i,j) is large, S(i,j + l) is also large. This leads us to the autocorrelation. 

First, consider a single row, i, in the similarity matrix and the autocorrelation function for that row 

![Equation28]({{ site.url }}/assets/images/equation2-8.PNG)

For a fixed value of i, this summation will tend to be large at values of l which cause peaks in row i to line up with peaks in the same row translated by the amount l. In other words, this summation will be large at values of l corresponding to a periodicity in row i of the S matrix. 
We can get a global measure by averaging these values together over all starting times i 

![Equation29]({{ site.url }}/assets/images/equation2-9.PNG)

	Assignment 
	9. Implement the computation of the rhythm index AC(l) defined 
	in (9). Plot the vector AC as a function of the 
	lag l = 0,1,...,Nf ‚àí 1 for the 12 tracks. Comment on the 
	presence, or absence, of a strong rhythmic pattern. 
	See Fig. 2 for an example of a plot of the rhythm index. 
	
MATLAB code for implementation of AC(l) is below:

```
function [ AC ] = autoC( filename,sim,~ ) 
%autoC Computes the autocorrelation of a song 
%   In general, if two frames i and j are similar, we can find out 
%   if they are repeated later in the segment, at time j+l   
info = audioinfo(filename); 
% sim = simMatrix( filename); 
[len,~]=size(sim); AC=zeros(1,len);   
parfor l=0:len-1     
	for i=1:len         
		for j=1:len-l             
			AC(l+1)=AC(l+1)+(sim(i,j)*sim(i,j+l));         
		end     
	end     
	AC(l+1)=AC(l+1)*(1/(len*(len-l))); 
end   
if(nargin==3)     
	h=figure;     
	xAxis=linspace(0,len/info.SampleRate,len);     
	plot(xAxis,AC);     
	xlim([0,len/info.SampleRate]);     
	title({'Autocorrelation AC(l):'; filename});     
	xlabel('Lag (secs)');     
	ylabel('Autocorrelation');     
	saveas(gca,['AutoC' filename(6:end-4) '.png']);     
	close(h); 
end   
end
```

The plot for AC(l) of ‚Äòtrack396-electronic‚Äô is shown in the figure below. The plot is very similar to the plot of B(l) and the better decision comes down to which method is faster for this specific track. 

![Figure24]({{ site.url }}/assets/images/figure2-4.PNG)

### 2.7 Rhythmic variations over time 

Here we are interested in studying the dynamic changes in the rhythm. For this purpose, we consider short time windows formed by 20 frames (approximately 1 second) over which we compute a vector AC of size 20 

![Equation210]({{ site.url }}/assets/images/equation2-10.PNG)
for l = 0,...,4, and m = 0,...,N<sub>f</sub>/20 ‚àí 1. 

	Assignment 
	10. Implement the computation of the rhythm index AC(l,m) defined 
	in (11). Plot the image AC in false color as a function of the 
	lag l = 0,...,19 (y-axis) and the time window index m (x-axis) 
	for the 12 tracks. Comment on the variation of rhythm patterns 
	for the different tracks. 
	
 MATLAB code used to implement AC(l, m) is below:
 
 ```
 function [ AClm ] = rhythmVar( filename,sim,~ ) 
 %Rhythm rhythmVar  
 %   In general, if two frames i and j are similar, we can find out 
 %   if they are repeated later in the segment, at time j+l 
 %   For the sake of this lab, we will be processing 20 frames (~1 second)   
 [len,~]=size(sim); 
 prod=zeros(20,20);   
 for l = 1:20          
 	for m = 1:floor(len/20)-1              
		for i = 1:20                  
			for j = 1:20-l+1                      
				prod(i,j) = sim(i+m*20,j+m*20)*sim(i+m*20,j+m*20+l-1);                 
			end              
		end              
		AClm(m,l) = 1/(20*(20-l))*sum(sum(prod(:,:)));             
		prod = 0;          
	end 
end           
if(nargin==3)     
	h=figure;     
	imagesc(AClm);     
	xlim([0, 20]);     
	ylim([0.5, 1.5])     
	title({'Autocorrelation AC(l,m):'; filename});     
	xlabel('Time (secs)');  
	ylabel('Lag (secs)');     
	colormap 'jet';     
	colorbar;     
	saveas(gca,['RhythmVar' filename(6:end-4) '.png']);     
	close(h); 
end 
end 
```

The following is the rhythmic variation of ‚Äòtrack396-electronic‚Äô and it can be seen that there are strong rhythmic patterns, but they are mostly the same so the chart is mostly blue.

![Figure25]({{ site.url }}/assets/images/figure2-5.PNG)

## 3. Tonality and Chroma 



	





