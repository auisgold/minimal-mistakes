---
title: "Rhythm and Chroma"
header:
  teaser: /assets/images/Lab2.png
categories:
  - Digital Signal Processing
tags:
  - rhythm
  - chroma
toc: true
---

# Introduction
In this project we look at how similar certain seconds in a music track are to each other, as well as look into the rhythm and chroma of a certain music track. We will use these features in a future project to compare two music tracks to see if they are part of the same genre of music using this analysis. 
<figure>
	<a href="/assets/images/Lab2.png"><img src="/assets/images/Lab2.png"></a>
</figure>

# Main Project

## 1. Intro

In this lab, we look at more digital signal processing for content-based music information retrieval. The two main features we are looking at are rhythm and tonality. We will be using the same tracks for lab 1 to investigate these features.  
These features are more useful for all frequencies of music as opposed to the features investigated in lab one that only helped for low frequency music. 

## 2. Rhythm 

Musical rhythm can be loosely defined as the presence of repetitive patterns in the temporal structure of music. We will implement several techniques to detect the presence of rhythmic structures in an audio track. 
Given an audio segment of duration T = 24 seconds, the goal is to compute a score that measures how often spectral patterns are repeated. Formally, we will compute a vector, B, such that B(lag) quantifies the presence of similar spectral patterns for frames that are lag frames apart. The lag associated with the largest entry in the array B is a good candidate for the period in the rhythmic structure.  
We explain below two approaches to compute the array B. 

### 2.1 Spectral Decomposition

We’ll first compute the mfcc coefficients for a frame as explained in lab 1, thereby obtaining a vector, and then modify each coefficient of the mfcc vector with a nonlinearity. The purpose of the non-linearity is to account for the non-linear perception of loudness by the human auditory system: loudness does not increase linearly with sound intensity (measured, for instance, in Watts/m<sup>2</sup>). A good approximation to the perceptual response of the human auditory system within a given critical band of hearing is obtained by taking the logarithm of the energy in that band. We therefore define an mfcc vector in decibels for each frame as 

![Equation21]({{ site.url }}/assets/images/equation2-1.PNG)

where the logarithm is taken of each element. 

Later you will write a function that returns an mfcc array, mfcc(k,n), comprising the mfcc vectors corresponding to each frame of an audio track. This array will have dimensions

![Equation22]({{ site.url }}/assets/images/equation2-2.PNG)

where N<sub>f</sub> = f<sub>s</sub>T/N. Here N<sub>f</sub> is the number of frames, N = 512 is the frame size in samples, f<sub>s</sub> is the audio sampling rate, and K = N/2 + 1 is the number of frequencies. As in lab 1, we choose nbanks = 40 as the number of mels. The entire analysis described below is performed at the level of frames. 

### 2.2 Spectrum histogram

We propose to construct a visual representation of a musical track by counting how often a given note is played at a given amplitude (we consider each index of the mfcc vector to be a “note”, and measure amplitude in dB). 

	Assignment
	1. Modify your function that computes the mfcc to return 
	the mfcc in decibels. 
	2. Construct a two-dimensional 
	spectrum histogram (a matrix of counts), with 40 
	columns —one for each mfcc index, and 81 rows —one for 
	each amplitude level, measured in dB. The amplitude range 
	we care about is from -20 dB to 60 dB, so clip the mel 
	values to that range. In other words, values less than 
	-20 dB map to -20, values greater than 60 dB map to 60, 
	and values inbetween map to the nearest integer in the 
	set {−20,−19,−18,...,60}. Once you have the counts, 
	normalize the histogram such that the sum along each 
	column (i.e. for each “note”) is one. 
	3. Display, using the MATLAB function imagesc, the 
	spectrum histogram for the 12 audio tracks supplied 
	for the first lab. 
	
1. Here is the MATLAB code of the function mfcc returned in decibels

```
function [ mfccp ] = mfcc( fbank,Xn,~) 
%mfcc Computes the Mel frequency coeffecients 
%   The mel-spectrum (MFCC) coefficient of the n-th frame is defined for 
%   p = 1,...,NB 
narginchk(2, 3); 
% Xn=freqDist(filename); 
mfccp=(fbank*abs(Xn)).^2; % Lets us still use non-log mfcc (if needed) 
if(nargin==3)     
	mfccp=10*log10(mfccp);     
	return; 
end 
end 

function [ soundExtract,p ] = extractSound( filename, time) 
%extractSound Extracts time (in seconds) from the middle of the song 
%   Write a MATLAB function that extract T seconds of music from a 
%   given track. You will use the MATLAB function audioread to 
%   read a track and the function play to listen to the track. 
narginchk(1, 2); 
if(nargin == 1)     
	time = 24; 
end 
info = audioinfo(filename); 
song=audioread(filename); 
if time >= info.Duration     
	soundExtract=song;     
	if(nargout == 2)         
		p=audioplayer(soundExtract,info.SampleRate);     
	end     
	return; 
elseif time<= 1/info.SampleRate     
	error('Too small of a time to sample'); 
end 
samples=time*info.SampleRate;   
soundExtract=song(floor(info.TotalSamples/2)-floor(samples/2):1: ...     
	floor(info.TotalSamples/2)+floor(samples/2)); 
if(nargout == 2)     
	p=audioplayer(soundExtract,info.SampleRate); 
end 
end
```

2, 3. In order to visualize the mfcc, a spectrum histogram is created which maps each mfcc index and the corresponding amplitude levels to a color displaying how often each mfcc index occured at the respective volume. Below is the histogram for ‘track201-classical’ which aside from the very low sounds, most of the pitches were at around the same volume.

![Figure21]({{ site.url }}/assets/images/figure2-1.PNG)

### 2.3 Similarity Matrix

The first stage involves computing a similarity matrix defined as follows 

![Equation23]({{ site.url }}/assets/images/equation2-3.PNG)

Here we are considering the mel spectral signature of each frame to be a vector, and using the dot product to compute S(i,j), the cosine of the angle between the vectors corresponding to frames i and j. For this exercise we use the non-dB version of the mfcc coefficients (i.e., we don’t first take 10 times the base 10 log of the mfcc values). We note that mfcc is always positive in this case, and therefore 0 ≤ S(i,j) ≤ 1. 

The similarity S(i,j) is large, S(i,j) ≈ 1, if the notes being played in frame i are similar to the notes being played in frame j. We note that this similarity is independent of the loudness of the music (the cosine between two vectors does not depend on their magnitude). 

	Assignment 
	4. Implement the computation of the similarity matrix, and display 
	the similarity matrices (color-coded) for the 12 audio tracks 
	supplied for the first lab. Use colormap(’jet’) and imagesc( ). 
	
The code for the similarity matrix and figure of ‘track201-classical’ for the similarity matrix is shown below.

```
function [ sim ] = simMatrix(mfccp,filename,~) 
%simMatrix displays the similarity matrix for the mel coefficients 
%   The similarity matrix is defined as follows: 
%   S(i,j) = sum_{k=1}^{nbanks}{ 
%   (mfcc(k,i)*mfcc(k,j))/(norm(mfcc(:,i)) * norm(mfcc(:,j))) 
% fbank=melBank(); 
% mfccp=mfcc(fbank,filename); 
[a,b]=size(mfccp); % Preallocate matrix 
sim=zeros(b,b); 
normI=sqrt(sum(abs(mfccp).^2,1)); 
parfor i=1:b %frame i     
	for j=1:b %frame j         
		for k=1:a %fbank k             
			sim(i,j)=sim(i,j)+...                 
				(mfccp(k,i)*mfccp(k,j)/(normI(j).*normI(i)));          
		end     
	end 
end   
if(nargin == 3)     
	h=figure;     
	imagesc(sim);     
	xlabel('Frame Number');     
	ylabel('Frame Number');     
	title({'Similarity Matrix:'; filename});     
	colorbar;     
	colormap 'jet';     
	saveas(gca,['SimMatrix' filename(6:end-4) '.png']);     
	close(h); 
end 
end	
```

In the figure it can be seen that classical music is mostly green and blue which is an indication that the music has a lot of different notes being played. As can be heard in the music, classical music has a widespread amount of notes being played throughout, so this physically makes sense for this track. 

![Figure22]({{ site.url }}/assets/images/figure2-2.PNG)
	





