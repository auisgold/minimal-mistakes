---
title: "MP3 Implementation"
header:
  teaser: /assets/images/Lab4.png
categories:
  - Digital Signal Processing
tags:
  - mp3
toc: true
---

# Introduction
In this project we implement the mp3 standard and look at how different compression ratios affect sound quality of a specific piece of music. This algorithm is frequently used to retain the salient features of music tracks, but decrease size so people can download and listen to their tracks in a reasonable amount of time. 
<figure>
	<a href="/assets/images/Lab4.png"><img src="/assets/images/Lab4.png"></a>
</figure>

# Main Project

## 1. Intro

In this lab we are investigating the features of Layer III of MPEGG 1, also known as mp3. We will first develop several subband filters to decompose and reconstruct the original audio signal. We will then be using a polyphaser pseudo Quadrature Mirror Filter to deconstruct and eventually reconstruct the original audio signal.  
This is a practice used to reduce the amount of space a certain song takes up on a hard drive while not compromising too much on the original audio signal. This is helpful for cloud based audio options such as Pandora or Spotify, as they have a lot of data to process from the hundred of thousands of songs in their libraries.  
 
## 2. Cosine Modulated Pseudo Quadrature Mirror Filter: Analysis 

In this section we give the detailed mathematical description of the analysis filter banks. We will manipulate the equations that combine convolution and decimation to arrive at a fast algorithm to compute the output signal, s<sub>k</sub>, for each of the 32 subbands. In section 2.1 we further describe the algorithmic implementation. 
Consider the 512 tap filter h<sub>k</sub>; the output of the combined filtering and decimation for this filter is given by 

![Equation41]({{ site.url }}/assets/images/equation4-1.PNG)

where

![Equation42]({{ site.url }}/assets/images/equation4-2.PNG)

and p<sub>0</sub> is a prototype lowpass filter. The frequency response of h<sub>k</sub> is clear: the modulation of p<sub>0</sub>[m] by

![Equation43]({{ site.url }}/assets/images/equation4-3.PNG)
shifts the lowpass filter’s frequency response to be centered around the frequency (2k+1)π/64, and thus h<sub>k</sub> will become
a bandpass filter that selects frequencies around (2k +1)π/64, for k = 0,...31, with a nominal bandwidth of π/32. 

This requires 32 × 512 = 16,384 combined multiplications and additions to compute the 32 outputs s1, …, s32 for each block  of 32 samples of the incoming signal x. In the following, we develop a faster algorithm to compute this operation. 
We start with 

![Equation41]({{ site.url }}/assets/images/equation4-1.PNG) 

and decompose the summation as follows (think of this as letting m = 64q + r): 

![Equation44]({{ site.url }}/assets/images/equation4-4.PNG) 

Next, we observe that since 

![Equation45]({{ site.url }}/assets/images/equation4-5.PNG) 

we can write 

![Equation46]({{ site.url }}/assets/images/equation4-6.PNG) 

Let us define, 

![Equation47]({{ site.url }}/assets/images/equation4-7.PNG) 

then 

![Equation48]({{ site.url }}/assets/images/equation4-8.PNG) 

Using the notations of the standard, we further define 

![Equation49]({{ site.url }}/assets/images/equation4-9.PNG) 

then

![Equation410]({{ site.url }}/assets/images/equation4-10.PNG) 

and 

![Equation411]({{ site.url }}/assets/images/equation4-11.PNG)

As a result of expressing the convolution of

![Equation41]({{ site.url }}/assets/images/equation4-1.PNG)

in the form of equation 

![Equation411]({{ site.url }}/assets/images/equation4-11.PNG)

 we can efficiently compute the sub band samples. For every n, we use the following three steps
 
 First, compute: 
 
![Equation412]({{ site.url }}/assets/images/equation4-12.PNG)
 
 Next, sum out the dependency on q via:
 
![Equation413]({{ site.url }}/assets/images/equation4-13.PNG)

Finally, compute one sample output for each subscribed via:

![Equation414]({{ site.url }}/assets/images/equation4-14.PNG)

This algorithm requires 2,560 multiplications and 2464 additions, but further speedup can be obtained using a fast DCT algorithm to compute matrix-vector multiplication.  

	Assignment 
	1. Write the MATLAB pqmf that implements the 
	analysis filter bank described above. The 
	function will have the following template: 
 
         [coefficients] = pqmf (input)  
 
         where input is a buffer that contains an 
	 integer number of frames of audio data. The 
	 output array coefficients has the same size 
	 as the buffer input, and contains the subband 
	 coefficients.  
 
	The array coefficients should be organized in the following manner: 
 
 	coefficients =  [S<sub>0</sub>[0]… S
	<sub>0</sub>[Ns – 1]  ...S<sub>31</sub>[0] ... 
	S<sub>31</sub>[Ns -1]] (22) where Si[k] is 
	the coefficient from subband i = 0,...,31 
	computed for the packet k of 32 audio samples. 
	Also NS is the total number of packets of 
	32 samples: 
 
 
	The organization of coefficients is such that the 
	low frequencies come first, and then the next 
	higher frequencies, and so on and so forth. 
 
	2. Analyze the first 5 seconds of the following tracks, and display the array coefficients, 
 
	sample1.wav,sample2.wav 
	sine1.wav,sine2.wav  
	handel.wav 
	cast.wav 
	gilberto.wav 
 
	Comment on the visual content of the arrays coefficients. 
 
 1. MATLAB code of the implementation of the pqmf function can be found below:
 
 ```
function [coefficients] = pqmf(inputBuffer, ~) 
%PQMF implements the analysis filter bank 
%Takes an input "inputBuffer" that contains an number of frames 
%of audio data. The output array "coefficients" as the same size  
%as the buffer "inputBuffer", and contains the subband coefficients   
filenameFlag = 0; 
if(ischar(inputBuffer))     
	filenameFlag = 1;     
	filename = inputBuffer;     
	info = audioinfo(filename);     
	SampleTime = 5;     
	if(SampleTime > info.Duration)        
		SampleTime = info.Duration;    
	end     
	inputBuffer = audioread(filename, [1,(info.SampleRate*SampleTime)]);     
	inputBuffer = inputBuffer(find(inputBuffer~=0,1):end); 
end   
totalSamples = length(inputBuffer); 
frameSize = 576; 
nFrame = floor(totalSamples/frameSize); 
inputBuffer = inputBuffer(1:(nFrame*frameSize)); 
[C,~] = loadwindow();   
M=zeros(32,64); 
for k=0:31     
	for r=0:63         
		M(k+1,r+1)=cos(((2*k+1)*(r-16)*pi)/64);     
	end 
end 
Ns=18*nFrame; 
bufferSize=512;
y=zeros(1,64); 
S=zeros(32,1);   
coefficients=zeros(size(inputBuffer)); 
packet=1;   
for frame = 1:nFrame         
% chunk the audio into blocks of 576 samples     
	offset = (frame -1)*frameSize+1;  % absolute address of the frame     
	frameTemp=inputBuffer(offset:(offset+frameSize-1));     
	Buffer=zeros(size(C));     
	for index = 1:18                % 18 non overlapping blocks of size 32         
		Buffer(1:bufferSize-32)=Buffer(33:end);         
		newBlock=frameTemp(((index-1)*32+1):index*32); % 32 new samples         
		Buffer((bufferSize-31):end)=newBlock;         % process a block of 32 new input samples         
		% see flow chart in Fig. 2         
		Z=C.*Buffer; % Window by 512 Coefficients to produce vector  
		for i=0:63             
			y(i+1)=sum(Z(i+64*(0:7)+1)); % Partial Calculation         
		end                  
		for i=0:31             
			S(i+1)=sum(M(i+1,:).*y); % Calculate 32 samples          
		end                  % Frequency inversion         
		if(mod(index,2)==1)             
			channel=1:2:32;             
			S(channel)=-S(channel); % invert odd-numbered frequencies         
		end         % Spaced Ns apart         
		coefficients(packet+(Ns*(0:31)))=S; % Assign coefficients                 
		packet=packet+1;     
	end % end index=1:18 
end % end frame=1:nFrame   
coefficients=coefficients/max(coefficients); % Normalize   
if(nargin == 2)     
	h = figure;     
	[~, name, exit] = fileparts(filename);     
	plot(coefficients);     
	title([name, exit, 'pqmf', num2str(SampleTime) 'seconds']);     
	xlabel('Coefficient');     
	ylabel('Amplitude');     
	saveas(gca, [name, '_', num2str(SampleTime), 'sec.png']);     
	close(h); 
end 
end
```

2. Below are the coefficients of sample1.wav. It can be seen the lower end of the PQMF coefficients are low, while they get larger as it approaches 5000. Listening to the song, this makes sense as the piano lacks a substantial bass, but higher pitches are heard very easily. 

![Figure41]({{ site.url }}/assets/images/figure4-1.PNG)


