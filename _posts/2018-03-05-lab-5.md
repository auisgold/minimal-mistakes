---
title: "JPEG Implementation"
header:
  teaser: /assets/images/Lab5.png
categories:
  - Digital Signal Processing
tags:
  - jpeg
toc: true
---

# Introduction
In this project we look at implementing the JPEG compression algorithm used in many images we see online. We see how different compression ratios affect an image and the noise around salient features of an image. Many images use JPEG as you can reduce the file size of an image greatly while still keeping many of the salient features intact. 

<figure>
	<a href="/assets/images/Lab5.png"><img src="/assets/images/Lab5.png"></a>
</figure>

# Main Project

## 1. Intro

In this lab we are implementing the JPEG algorithm used for image compression. We do this so that images can be transferred and stored efficiently and to save space. Uncompressed images are very difficult to store, so storing these images digitally is very advantageous.

We are using an encoding/decoding algorithm in order to achieve compression on luminance (gray-level) images. The main part of this lab is using the Discrete Cosine Transform (DCT) to describe an image using a smaller set of coefficients to represent the original image. These values are put through a quantization table to decrease the information needed to represent the coefficients created through the DCT. Then we decode the information from these steps to get a new image that is compressed that uses less space than the original picture. 

## 2. The JPEG Compression Algorithm 

To implement the JPEG compression algorithm we start by taking the forward and inverse DCT. To implement the forward DCT the original image is divided into non overlapping blocks size 8x8. Each block gets transformed using the 2D DCT expressed as,

![Equation51]({{ site.url }}/assets/images/equation5-1.PNG)

where C<sub>v</sub> follows the same rule as C<sub>u</sub> and

![Equation52]({{ site.url }}/assets/images/equation5-2.PNG)

These coefficients are an approximation and do introduce distortion and slight loss in image quality. 

![Equation53]({{ site.url }}/assets/images/equation5-3.PNG)

	Assignment:
	1. Write the MATLAB function dctmgr that implements 
	the following functionality:
		(a) it takes a luminacnce (grey-level) image
		as an input, divides it into non overlapping
		8 x 8 blocks, and DCT transforms each block
		accoring to the 2D DCT. 
		(b) The DCT coefficients for the entire image are
		returned into a matrix coeff of size 64 x 
		N<sub>blocks</sub>, where N<sub>blocks</sub> is the number of 8x8 blocks
		inside the image. 
		(c) For a given block b, the coefficients of the 
		column coeff(:,b) are organized according
		to the zig-zag order shown in Fig. 3. That is, 
		coeff(2,b) = F(1,2), coeff(3,b) = F(2,1), coeff(3,b) = F(3,1), ...
		(d) The zero-frequency "DC" coefficients, F(1,1), 
		for each block are encoded using differential encoding
		(i.e each DC coefficient is predicted either 0
		if it is the start of a new row, or by the
		DC coefficient of the block to its left). As
		an example:
		coeff(1,1) = F<sub>1</sub>(1,1) - 0, 
		coeff(1,2) = F<sub>2</sub>(1,1) - F<sub>1</sub>(1,1),
		coeff(1,3) = F<sub>3</sub>(1,1) - F<sub>2</sub>(1,1),
		...
		where F<sub>i</sub>(1,1) is the zero frequency DCT
		coefficient of block i. Image blocks should be 
		processed in a left-to-right and top-to-bottom order.
		When starting each new row of 8-by-8 blocks, the 
		predictor of the DC coeffiecient is reset to 0 (in
		other words, don't use the last block of one row to
		predict the first block of the following row). 
	2. Write the MATLAB function idctmgr that implements the 
	following functionality. 
		(a) It takes a matrix coeff of size 64 x N<sub>blocks</sub>, 
		where N<sub>blocks</sub> is the number of 8 x 8 blocks inside the
		image and reconstructs a luminance image. 
		(b) For each block b, the coefficients in the column
		coeff(:,b) are used to reconstruct the block according to the
		reconstructed DCT equation. You should write an inverse
		2-D DCT routine using matrix multiplication. Keep in mind
		that you have to undo the prediction used for the DC coefficients
		to recover their true values. 

1) The function dctmgr is shown below:

```
function [coefficients, temp] = dctmgr(image, lossFactor) 
%dctmgr Creates JPEG coefficients for an image 
%Takes a luminance (gray-level) image as an input, divives it into 
%non overlapping 8x8 blocks, and uses the DCT transform on each block according 
%F(u,v) = 1/4*C_u*C_v sum(f(x,y)*cos(((2x+1)*u*pi)/16) * %cos(((2y+1)*v*pi)/16), u,v = 0,...,7. For a given block b, 
%the coefficients of the column coefficients(:,b) are organized in a  
%zig-zag pattern. The zero-frequency coefficients, F(1,1), for each block 
%is encoded using differential encoding: coefficients(1,1) = F_1(1,1); 
%coefficients(1,2) = F_2(1,1) - F_1(1,1); where F_i(1,1) is the zero 
%frequency DCT coefficient of block i   
[x,y] = size(image); 
index = 1; 
coefficients = zeros(64,x*8); 
dctMatrix = zeros(x,y); 
for x2 = 1:8:x     
	for y2 = 1:8:y         
		temp = image(x2:x2+7,y2:y2+7);         
		firstDct = dct2(temp);         
		firstDct = quantization(firstDct,lossFactor);         
		dctMatrix(x2:x2+7,y2:y2+7) = firstDct;         
		%coefficient matrix:         
		coefficients(:,index) = zigZag(firstDct);         
		index = index + 1;     
	end 
end 
temp = coefficients(1,:); 
for i = 2:y*8     
	coefficients(1,i) = temp(1,i) - temp(1,i-1); 
end
end
```

2. The function idctmgr is included below:

```
function [output] = idctmgr(coefficientMatrix,temp,lossFactor)
%(a) It takes a matrix coeff of size 64 x Nblocks, where Nblocks is the number of 8 x 8 blocks 
% inside the image and reconstruct a luminance image. 
% (b) For each given block b, the coefficients in the column coeff(:,b) are used to reconstruct 
% the block according to (3). 
firstiDct = zeros(8,8); 
output = zeros(512,512); 
[x,y] = size(coefficientMatrix); 
coefficientMatrix(1,:) = temp; 
index = 1;          
for x2 = 1:8:505              
	for y2 = 1:8:505                  
		firstiDct = inverseZigZag(coefficientMatrix(:,index));                 
		firstiDct = inverseQuantization(firstiDct,lossFactor);                 
		output(x2:x2+7,y2:y2+7) = idct2(firstiDct);                 
		index = index + 1;              
	end          
end 
end
```

The next step in the JPEG standard is quantization. The effect of the DCT is to create many small coefficients that are close to zero, and a small number of large coefficients. The goal of quantization is to represent a continuum of values with a finite small set of symbols. In JPEG the quantization of the DCT coefficients other than the DC coefficient is performed as follows.  
 
![Equation54]({{ site.url }}/assets/images/equation5-4.PNG)

After using the quantization, we take the inverse that is defined by the map 

![Equation55]({{ site.url }}/assets/images/equation5-5.PNG)

We notice that by doing this, the compression becomes lossy during the quantization step as it creates many zero coefficients as the loss factor becomes larger. As a result, it becomes possible to spend fewer bits. 

	Assignment:
	3. 
 




